# Provenção de Software
A proveniência de software é a história de um produto de software, desde o início até o processo de fabricação.

A cronologia da origem, desenvolvimento, propriedade, localização e alterações em um sistema ou componente do sistema e dados associados.

Também pode incluir pessoal e processos usados para interagir ou fazer modificações no sistema, componente ou dados associados. ”- [Instituto Nacional de Padrões e Tecnologia](https://csrc.nist.gov/glossary/term/provenance)

A prova é alcançada através da geração de artefatos que fornecem evidências do trabalho que foi feito em todas as etapas do ciclo de vida de desenvolvimento de software, permitindo que os usuários inspecionem e validem o processo de forma confiável.

Sem proveniência, os vários elementos que compõem nosso software não podem ser rastreados até a fonte. Ao capturar a proveniência de forma consistente e automatizada, os produtores de software são capazes de estabelecer melhor a confiança com os usuários finais.

# Como a Provenção de Software é estabelecida?
O principal fator para a proveniência do software é mostrar a prova de trabalho em cada estágio.

O primeiro passo, e mais comumente implementado para a proveniência, é usar um sistema de controle de origem (também conhecido como sistema de controle de versão).

Hoje, a ferramenta Git é amplamente utilizada como um sistema de controle de código fonte, por isso vamos nos concentrar no Git (embora os princípios também se apliquem a ferramentas semelhantes).

Ao usar corretamente o Git, estamos gerando um histórico de cada alteração no código-fonte enquanto simplificamos os controles sobre como o código-fonte é modificado.

A segunda parte do processo de proveniência é rastrear claramente as dependências que estão incluídas na compilação, que é comumente feita através de ferramentas específicas de linguagem e formatos que registram essas dependências (como requirements.txt para Python e package-lock.json para npm).

Para permitir melhor o consumo de informações de dependência para as partes interessadas, os projetos podem compilar essas informações em uma *lista de materiais de software (SBOM)*.

Depois que estes forem concluídos, o passo final será criar um **software attestation**.

Não deve ser confundido com um [atestado remoto](https://en.wikipedia.org/wiki/Trusted_Computing#Remote_attestation), o atestado de software é metadados assinados em relação a um artefato de software ou conjunto de artefatos.

Quando esses atestados são fornecidos aos usuários, eles podem agora validar a confiabilidade de todos os artefatos antes do uso.

A automação tornará muito mais fácil começar a estabelecer a proveniência para o seu projeto. Além disso, é necessário para realizar tudo isso de maneira consistente e repetível.

# Benefícios da Provenção Automatizada de Software

O projeto SLSA dá vários [exemplos de casos de uso](https://slsa.dev/spec/v1.0/use-cases) em [](https://slsa.dev/spec/v1.0/use-cases)a proveniência automatizada provou ser benéfica:

- O Google (estudo de caso Google [Binary Authorization for Borg](https://cloud.google.com/docs/security/binary-authorization-for-borg)) reduz o risco _primário_ dentro de uma organização de insiders e contas comprometidas.
- A SUSE (estudo de caso SUSE [Securing the Software Supply Chain](https://documentation.suse.com/sbp/server-linux/html/SBP-SLSA4/index.html)) reduz o risco para usuários finais de _código aberto_ que consomem seu software de código aberto.
- Uma variedade de _fornecedores_ reduz o risco de consumir software e serviços fornecidos pelo fornecedor.

Veja como eles dividem os benefícios acima mencionados (na página vinculada acima).


|                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Primeira festa                | - Uma pequena empresa ou equipe usa o SLSA para garantir que o código que está sendo implantado na produção em forma binária seja o mesmo que foi testado e revisado na forma de origem.<br>- Uma grande empresa usa o SLSA para exigir a revisão de duas pessoas para cada mudança de produção, escalonosamente em centenas ou milhares de funcionários / equipes.<br>- Um projeto de código aberto usa o SLSA para garantir que as credenciais comprometidas não possam ser abusadas para liberar um pacote não oficial para um repositório de pacotes. |
| Consumidores de código aberto | - No momento do upload, o registro do pacote rejeita o pacote se ele não foi construído a partir do repositório de origem canônico.<br>- No momento do download, o cliente de embalagem rejeita o pacote se não foi construído por um construtor confiável.                                                                                                                                                                                                                                                                                               |
| Vendedores                    | - Prefira os fornecedores que fazem reivindicações do SLSA e apoie-os com evidências confiáveis.<br>- Exigir que um fornecedor implemente o SLSA como parte de um contrato.<br>- Exigir que um fornecedor seja certificado pelo SLSA de um auditor de terceiros confiável.                                                                                                                                                                                                                                                                                |

Embora a documentação do SLSA chame esses beneficiários diretamente, é importante observar os benefícios indiretos que podem ser obtidos.

Uma empresa regulamentada pode ser mais adequada para demonstrar conformidade.

Projetos de código aberto podem ganhar maior confiança de usuários finais com mentalidade de segurança.

Os fornecedores podem achar que a adoção e a integração se tornam simplificadas e os períodos de revisão de segurança encurtados.

Como continuamos a explorar este tópico em capítulos subsequentes, é altamente provável que você encontre um ganho líquido configurando a proveniência automatizada em seu ciclo de vida de desenvolvimento de software.

# Termos-chave

Os seguintes termos serão úteis para lembrar à medida que continuamos neste curso.

- **Software Provenance**: O histórico de um produto de software, incluindo sua origem, desenvolvimento, propriedade, mudanças e dados associados.
- **Artefatos**:  Evidências geradas em cada etapa do ciclo de vida de desenvolvimento de software, fornecendo um registro do trabalho realizado.
- **Dependências**: Bibliotecas externas, pacotes ou módulos dos quais um projeto de software se baseia.
- **Software Bill of Material (SBOM)**: Uma lista de todas as dependências de software e seus relacionamentos em um projeto.
- **Assinatura**: Uma assinatura criptográfica aplicada aos artefatos liberados, garantindo sua integridade e autenticidade.
- **Atestado de Nascimento**: Uma declaração autenticada sobre um ou mais artefatos de software.

# Aproveitando a história do Git
Assumindo o uso adequado, o Git rastreia inerentemente cada mudança em nosso software. O uso inadequado inclui rebaseamento após a fusão, entre outras coisas que você provavelmente pode imaginar.

O uso adequado envolve a inclusão do sinalizador **de** **sinalização** ou ao fazer commits Git, além de outros padrões normais, como descrições efetivas fornecidas com cada commit.

Um repositório Git devidamente protegido incluirá proteção de ramificação que requer assinaturas em cada commit e solicitações de pull obrigatórias antes que o código seja mesclado para o ramo principal.

Nas seções a seguir, vamos explorar como fazer isso dentro do contexto do GitHub. Recursos semelhantes existem em outros provedores de controle de origem, como o GitLab e o BitBucket.

# Aproveitando a história do Git
Assumindo o uso adequado, o Git rastreia inerentemente cada mudança em nosso software. O uso inadequado inclui rebaseamento após a fusão, entre outras coisas que você provavelmente pode imaginar.

O uso adequado envolve a inclusão do sinalizador **de** **sinalização** ou ao fazer commits Git, além de outros padrões normais, como descrições efetivas fornecidas com cada commit.

Um repositório Git devidamente protegido incluirá proteção de ramificação que requer assinaturas em cada commit e solicitações de pull obrigatórias antes que o código seja mesclado para o ramo principal.

Nas seções a seguir, vamos explorar como fazer isso dentro do contexto do GitHub. Recursos semelhantes existem em outros provedores de controle de origem, como o GitLab e o BitBucket.

# Como estabelecer sua identidade Git
Uma vez que a proteção de ramificação é configurada, os contribuidores devem seguir os passos abaixo para fazer commits que aderem à nova política.

Como agora exigimos que os commits sejam assinados, precisamos fornecer instruções aos nossos desenvolvedores sobre como eles podem configurar seus clientes Git para assinatura.

Um passo comumente visto seguido por desenvolvedores ao configurar as credenciais do Git pela primeira vez é definir o nome e o e-mail do usuário nas configurações globais do Git. Um exemplo disso pode ser visto aqui:

**git config user.name "Primeiro nome"
git config user.email "developer?email" (em inglês)**

Estas instruções também são fornecidas neste [Guia de Introdução](https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup) para o Git.

Em seguida, precisaremos configurar nosso Git CLI para usar o GPG ou SSH para commits Git. Por exemplo, para configurar o Git com uma chave SSH gerada, usamos o seguinte comando (substituindo informações apropriadas):

**git config --global user.signingkey /PATH/TO/. SSH/KEY.PUB**

Visite [esta documentação](https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key?platform=linux) para obter mais informações sobre como configurar suas chaves no GitHub.

Quando configuramos o Git para incluir nossas chaves de assinatura, estamos fornecendo-as como metadados adicionais ao lado de nossos commits. Quando pressionamos o commit, nossa chave é comparada à chave pública que demos ao provedor de controle de origem para verificar se nosso commit vem de uma fonte genuína.

Agora você pode assinar seus commits usando essa chave simplesmente adicionando **-s** ou **--signoff** ao comando.

**git commit --signoff -m “este é um commit assinado”**

Se as chaves Git não estiverem configuradas corretamente, você poderá receber um erro como o seguinte:

**erro: gpg não assinou os dados
fatal: não conseguiu escrever objeto de commit**

Se for bem-sucedida, sua mensagem de confirmação agora incluirá uma observação de assinatura que se parece com isso:

**Este é um commit assinado
Assinado-fora: Colin Griffin ?colin?krum.io?**

Agora que configuramos com sucesso o Git, estamos prontos para começar a fazer outras alterações em nosso repositório, incluindo a atualização de nossas Ações do GitHub.

# Começando com a Repo Security

Quando implementado corretamente, as proteções de segurança no provedor de controle de fonte transformarão nosso histórico Git em nosso primeiro artefato de proveniência. Se estes não estiverem no lugar corretamente, você pode não estar aproveitando ao máximo o seu uso do Git.

As páginas seguintes demonstram como implementar essas proteções nas configurações do repositório de administração do GitHub. Mais uma vez, o conceito deve ser verdadeiro dentro de qualquer plataforma semelhante.

_**NOTA:** Se você já está intimamente familiarizado com a assinatura de commits e proteções de recompra, você pode ser capaz de pular para o Capítulo 4 neste momento._

# Signoff em Commissos baseados na Web

Antes de começarmos com proteções específicas de ramificação, precisamos exigir que os colaboradores se inscrevam em commits baseados na web. Isso entra em vigor em todo o repositório, impedindo que os contribuidores ignorem os requisitos de assinatura ao usar o editor no navegador GitHub.

![](https://d36ai2hkxl16us.cloudfront.net/course-uploads/e0df7fbf-a057-42af-8a1f-590912be5460/iwfq7i6aqsye-ScreenshotoftheGitHubrepo.png)

**Imagem de tela das configurações do repositório do GitHub, mostrando a tela de configurações de um repositório do GitHub**

Observe a descrição útil na imagem acima: “Assinar fora é uma maneira de os contribuidores afirmarem que seu commit está em conformidade com os termos do repositório (...).”

Também digno de nota, existem dois links úteis incluídos nesta página que você pode considerar adicionar à sua documentação para passar para os desenvolvedores. Estes serão úteis para comunicar com os colaboradores a importância de assinar seus commits, então aqui eles estão novamente para referência:

- [Certificado de origem do desenvolvedor (DCO)](https://developercertificate.org/)
- [Saiba mais sobre a assinatura em commits](https://docs.github.com/en/organizations/managing-organization-settings/managing-the-commit-signoff-policy-for-your-organization)

# Edite as regras de proteção da filial

Em seguida, precisamos editar as regras de proteção Branch. Abra a página _Ramos_ nas configurações do repositório do seu projeto e clique em "Editar" na ramificação que você deseja proteger.

![](https://d36ai2hkxl16us.cloudfront.net/course-uploads/e0df7fbf-a057-42af-8a1f-590912be5460/twxtsd6glck3-Editingbranchprotectionrules.png)

**Captura de tela das configurações do repositório do GitHub, direcionando os usuários para selecionar o menu Filiais e, em seguida, Editar o botão na ramificação 'principal'**

# Exigir alterações aprovadas

Em seguida, você pode decidir implementar alguns controles adicionais para impor fluxos de trabalho de segurança fortes. Ao designar proprietários de código e exigir aprovações de proprietários de código, você construirá confiança com os consumidores.

![](https://d36ai2hkxl16us.cloudfront.net/course-uploads/e0df7fbf-a057-42af-8a1f-590912be5460/pfkwzab4dlwf-Protectingmatchingbranches.png)

**Captura de tela das configurações do repositório do GitHub, mostrando as regras de proteção de ramificações selecionadas**

# Exigir verificações de status

_**NOTA:** Isso é opcional, não coberto neste curso._

Você também pode considerar a necessidade de verificações adicionais para serem realizadas em pedidos pull. Você pode considerar a adição de digitalização de dependência como uma verificação junto com linting ou outras etapas de análise de código para "deslocar para a esquerda", como proteção adicional.

![](https://d36ai2hkxl16us.cloudfront.net/course-uploads/e0df7fbf-a057-42af-8a1f-590912be5460/ewnfv8ogi1xd-Checkingthestatus.png)

**Captura de tela das configurações do repositório do GitHub, mostrando os requisitos de verificação de status**

# Exigir compromissos assinados

Finalmente, selecione a opção que os commits assinados são necessários.

![](https://d36ai2hkxl16us.cloudfront.net/course-uploads/e0df7fbf-a057-42af-8a1f-590912be5460/blhpnc8g5f2q-Signingcommits.png)

**Captura de tela das configurações do repositório do GitHub, mostrando a opção para exigir commits assinados**

Agora que concluímos essas etapas, começamos a proteger nosso repositório de fontes não reconhecidas, bem como a impor a proveniência do edifício.

# Objetivos de aprendizagem

No final deste capítulo, você aprenderá sobre técnicas de rastreamento de dependência e se familiarizará com os conceitos básicos de Software Bill of Materials (SBOM), bem como os formatos CycloneDX e SPDX.

# Noções básicas de rastreamento de dependência

A maioria das aplicações modernas usará uma ferramenta específica de linguagem para gerenciar o consumo de dependências. Exemplos de listas de dependências detalhadas incluem **o package-lock.json** do Javascript e o Go's **go.sum**. O maior benefício surge quando rastreamos dependências diretas e transitivas.

- Dependências diretas são aquelas que seu software importa e usa dentro da base de código.
- Dependências transitórias são aquelas que não são nomeadas explicitamente pelo seu software, mas são exigidas por outra dependência e são posteriormente trazidas para o seu projeto no momento da compilação.

# Dificuldades e deficiências
Como você pode ver no Argo CD **[go.sum](https://raw.githubusercontent.com/argoproj/argo-cd/master/go.sum)**, ele fornece uma fonte de veracidade listando todas as dependências diretas e transitivas, enquanto o mesmo codebase **[go.mod](https://github.com/argoproj/argo-cd/blob/master/go.mod)** nomeia apenas as dependências que o projeto usa diretamente.

No entanto, manter esses dados com precisão geralmente requer cuidados especiais, manualmente ou por meio de automação. Continuando com o nosso exemplo, o [Gráfico de Dependência](https://github.blog/changelog/2023-03-07-dependency-graph-removes-go-sum-support/) do GitHub não suporta mais go**.sum** devido a nuances na forma como ele registra as dependências consumidas durante as compilações.

Considerando o valor fornecido pelo rastreamento de dependências e a dificuldade de obter o valor mais completo do processo, o setor (e muitas agências reguladoras) se moveram em direção a SBOMs.

# O que é uma conta de software de materiais (SBOM)?

Muitos palestrantes e escritores usam analogias para ajudar a comunicar o que é uma lei de materiais de software, comparando-a com a lista de ingredientes em alimentos ou a lista de componentes de um carro.

Mas somos todos engenheiros de software aqui – e acabamos de discutir o rastreamento de dependências – então você deve ter uma rampa fácil para entender os SBOMs (se você ainda não o fizer).

Ao contrário do esmagamento de dependência fornecido por coisas como **o go.mod**, uma lista de software de materiais é um documento legível por máquina altamente estruturado que rastreia todas as dependências diretas e transitórias e seus relacionamentos.

O processo de criação do SBOM geralmente cria situações em que os projetos são apresentados com insights que informam melhorias de segurança. O SBOM finalizado atende às partes interessadas (incluindo usuários finais), pois pode ser rapidamente integrado a ferramentas de automação de gerenciamento de dependências para simplificar melhores decisões de consumo de software.

Um benefício muitas vezes negligenciado para a criação e consumo da SBOM é que – além dos benefícios diretos fornecidos pelo próprio SBOM – o processo de trabalhar com um SBOM cria oportunidades onde os profissionais podem considerar e implementar melhorias de segurança.

Os dois formatos mais comumente implementados para criar um SBOM são [o CycloneDX](https://cyclonedx.org/) e [o SPDX](https://spdx.dev/), que exploraremos mais na página seguinte em seus próprios termos. Escolha a solução que melhor se integra ao seu ecossistema.

_**NOTA:** Não se preocupe muito em bloquear em um formato. Existem opções disponíveis, como as detalhadas neste [guia](https://blog.sonatype.com/how-to-convert-your-sbom-between-spdx-and-cyclonedx-formats), para converter entre os formatos SBOM._

# CicloneDX e SPDX

## CycloneDX jogo:
[O CycloneDX](https://cyclonedx.org/) é um padrão completo de Bill of Materials (BOM) que fornece recursos avançados da cadeia de suprimentos para redução de riscos cibernéticos. A especificação suporta:

- Software Bill of Material (SBOM)
- Software-as-a-Service Bill of Materials (SaaSBOM)
- Projeto de Hardware de Materiais (HBOM)
- Projeto de Lei de Materiais (OBOM)
- Relatórios de divulgação de vulnerabilidades (VDR)
- Vulnerability Exploitability eXchange (VEX)

A direção estratégica da especificação é gerenciada pelo Grupo de Trabalho Core CycloneDX, apoiado pela Fundação OWASP e apoiado pela comunidade global de segurança da informação.

### SPDX em Inglês
[O SPDX](https://spdx.dev/about/) é um padrão aberto para a comunicação de informações de informações de materiais de software, incluindo proveniência, licença, segurança e outras informações relacionadas. O SPDX reduz o trabalho redundante, fornecendo formatos comuns para organizações e comunidades compartilharem dados importantes, simplificando e melhorando a conformidade, a segurança e a confiabilidade. A especificação SPDX é reconhecida como o padrão aberto internacional para segurança, conformidade de licenças e outros artefatos da cadeia de suprimentos de software como ISO/IEC 5962:2021.

SPDX é um projeto de código aberto hospedado pela Linux Foundation. O esforço de base inclui representantes de um conjunto diversificado de organizações – software, fornecedores de sistemas e ferramentas, fundações e integradores de sistemas.

O projeto SPDX é composto por:

- A especificação SPDX em si.
- A Lista de Licenças SPDX (incluindo exceções, diretrizes de correspondência, IDs de licença e sintaxe de expressão de licença).
- Ferramentas e bibliotecas do SPDX para trabalhar com os documentos SPDX e a Lista de Licenças SPDX.

# O valor agregado por etiquetas de liberação

Cada vez que criamos uma tag para um lançamento, ele gera um histórico de nossas versões de pacotes de lançamento pretendidos. Os artefatos estão ligados a essas tags em gerenciadores de repositórios populares como o GitHub.

Conforme detalhado na [documentação](https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases#about-releases) de [](https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases#about-releases)do GitHub, uma tag Git é na verdade uma referência a um commit. Quando marcamos uma versão, ela fornece uma maneira mais fácil de identificar e associar nossos artefatos que são gerados a partir desse ponto e tempo específicos no código-fonte.

Além disso, se o formato de tag de liberação seguir o Versionamento semântico ou outro formato de versão parsável, os usuários podem seguir uma abordagem padronizada para selecionar seus artefatos desejados.

Mesmo com esse benefício adicional, os usuários finais ainda são recomendados para fixar suas dependências ao hash de commit associado à versão desejada. Isso evita que quaisquer complicações decorrentes de uma tag Git sejam recriadas para apontar para um commit diferente. Isso dá aos usuários a confiança de que seu recurso confiável não é alterado para uma fonte não confiável sem autorização ou um registro da mudança.

# O valor agregado por assinaturas de liberação

Uma assinatura de versão é um selo criptográfico de autenticidade e integridade aplicado a um pacote de lançamento. Ele permite que os usuários finais garantam que o pacote não foi adulterado e que ele se origina de uma fonte confiável.

Quando um lançamento é assinado, isso significa que o produtor de software atestou sua autenticidade. Os usuários podem verificar essas assinaturas para confirmar que a versão não foi alterada desde que foi assinada e que, de fato, vem de uma entidade confiável. Esse processo de verificação aumenta a confiança no pacote de lançamento, especialmente em cenários em que a segurança e a confiabilidade são fundamentais.

Ao combinar tags Git para identificação de versão e liberar assinaturas para autenticidade, os consumidores de software podem tomar decisões informadas sobre quais artefatos confiar e usar em seus projetos. Essas práticas contribuem significativamente para a confiabilidade e segurança da cadeia de suprimentos de software.

No capítulo seguinte, estaremos automatizando assinaturas como parte do processo de cosign (que também gera atestados).

# O que é o SLSA?

O SLSA é um conjunto de diretrizes para a adoção da segurança da cadeia de suprimentos, focada no estabelecimento da integridade. Ele estabelece uma estrutura mensurável contra a qual podemos desenvolver nossa automação da cadeia de suprimentos e ajudar a evitar a adulteração ou modificação de software em qualquer estágio da produção de artefatos, enquanto documentamos informações detalhadas sobre o processo de construção e embalagem.

[Proveniência](https://github.com/slsa-framework/slsa-verifier#what-is-provenance) é definida como “informação ou metadados, sobre como um artefato de software foi criado. Isso pode incluir informações sobre quais códigos-fonte, sistema de compilação e etapas de compilação foram usadas, bem como quem e por que a compilação foi iniciada. A prova pode ser usada para determinar a autenticidade e a confiabilidade dos artefatos de software que você usa. Para saber mais sobre a proveniência, consulte [a documentação do SLSA](https://slsa.dev/spec/v1.0/provenance).

Como isso é diferente de um SBOM? O SLSA está focado no processo de construção, não nos detalhes detalhados sobre a composição do software, que é fornecido através de um SBOM. Os dois conceitos são de fato complementares e serão demonstrados juntos em seções posteriores para aplicação de automação.

Ao seguir o SLSA, somos capazes de implementar ferramentas que nos ajudam a gerar proveniência e estabelecer confiabilidade do processo de construção. Os consumidores precisam ser capazes de confiar não apenas nos próprios artefatos, mas também nos fornecedores e produtores dos artefatos.

Conforme descrito neste diagrama do SLSA, esta estrutura estaremos trabalhando para proteger nosso software de ameaças como a construção de código-fonte modificado (marcador C) através do consumo e verificação de pacotes (marcador H). Também iremos comunicar isso aos nossos usuários na forma dos metadados de proveniência gerados.

![](https://d36ai2hkxl16us.cloudfront.net/course-uploads/e0df7fbf-a057-42af-8a1f-590912be5460/9qogdf4zd5b9-SupplyChainThreats.png)

**Diagrama de ameaças à cadeia de suprimentos de software**
Recuperado da [documentação do SLSA](https://slsa.dev/spec/v1.0/threats-overview)

# Níveis SLSA

Uma das vantagens de seguir o SLSA é que o padrão para assinatura dos artefatos gerados por nós é claramente articulado com três níveis de maturidade. Cada nível deve incluir o nível anterior, permitindo que os adotantes avancem rumo ao Nível 3 por meio de aprimoramentos. Avaliaremos esses níveis em alto nível.

**Tabela 5.1: Níveis de trilha de construção do SLSA (Fonte: [Níveis de segurança do SLSA](https://slsa.dev/spec/v1.0/levels) )**

| Trilha/Nível | Requisitos                                                               | Foco                             |
| ------------ | ------------------------------------------------------------------------ | -------------------------------- |
| Construir L0 | (nenhum)                                                                 | (n / D)                          |
| Construir L1 | Proveniência mostrando como o pacote foi construído                      | Erros, documentação              |
| Construir L2 | Proveniência assinada, gerada por uma plataforma de construção hospedada | Adulteração após a construção    |
| Construir L3 | Plataforma de construção reforçada                                       | Adulteração durante a construção |

|                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Nível 1 - Existe proveniência                          | No primeiro nível, as organizações estão implementando os princípios básicos da proteção contra adulteração. Isso inclui seguir um processo de compilação consistente, gerar a procedência automaticamente e distribuí-la aos consumidores. Nesta fase, provavelmente estamos clonando diretamente do repositório com um executor ou script de compilação e compilando e publicando artefatos imediatamente. Com um processo de compilação mais consistente do que um processo totalmente manual, estamos limitando erros e tornando nossas compilações mais confiáveis.                                                                                                                                                     |
| Nível 2 - Plataforma de construção hospedada/confiável | O segundo nível inclui os requisitos do Nível 1, mas também introduz compilações em um sistema hospedado, independente dos desenvolvedores de software. Ao permitir que as compilações sejam realizadas de forma isolada, ele limita a superfície de ataque, limitando as compilações a ambientes específicos que podem ser auditados e reforçados. As compilações também são assinadas pela própria plataforma de compilação.                                                                                                                                                                                                                                                                                               |
| Nível 3 - Construções reforçadas                       | Finalmente, no terceiro nível, nossa plataforma de build foi reforçada e controles rigorosos foram implementados. Os builds devem ser executados de forma independente e não influenciar uns aos outros, e o material de assinatura só é acessível por meio de segredos. Com esses controles em vigor, deve ser extremamente difícil para adversários afetarem a produção dos artefatos, e provavelmente também tem o benefício de dificultar ataques ao código-fonte. Ao implementar a automação, usaremos o GitHub Actions como uma plataforma de compilação confiável e a ferramenta fornecida pelo SLSA, chamada slsa-github-generator. Isso nos permitirá implementar o SLSA Nível 3 com alterações mínimas no projeto. |

Automatically Generate Your SBOM on Release

## Plug-in Maven CycloneDX

Somente Java.

Este plugin pode criar SBOMS para módulos, pacotes ou ser executado na raiz de um projeto para criar a lista de materiais para tudo o que encontrar.

A [documentação](https://github.com/slsa-framework/slsa) é bem organizada e você começará a usar em segundos.



BÔNUS : Se você estiver enviando para o Maven Central , poderá comparar seu SBOM com a análise de dependências fornecida pela Sonatype em sua página pública. Há também uma Classificação de Segurança da Sonatype que ajudará a selecionar seus próximos passos para proteger a cadeia de suprimentos do seu projeto Java.



O [plugin Maven CycloneDX](https://github.com/CycloneDX/cyclonedx-maven-plugin) gera a Lista de Materiais de Software (SBOM) CycloneDX contendo o agregado de todas as dependências diretas e transitivas de um projeto.

O CycloneDX é um padrão leve de lista de materiais de software (SBOM) projetado para uso em contextos de segurança de aplicações e análise de componentes da cadeia de suprimentos.



## GoReleaser

Se você estiver usando o GoReleaser para o seu projeto Go, agora pode criar e lançar um SBOM em tempo de compilação, usando a versão 1.20.0 ou posterior! Você pode aproveitar isso de qualquer uma das maneiras que normalmente usa o GoReleaser, inclusive por meio da Ação oficial do GitHub.

“ O GoReleaser foi criado para resolver um problema que todos nós já tivemos: lançar software é algo chato e sujeito a erros. Para resolver isso, todos nós acabamos criando scripts para automatizar o trabalho, com vários níveis de sucesso. (...) O objetivo do GoReleaser é tornar todos esses scripts obsoletos: em vez de escrever scripts, você escreve um simples arquivo de configuração YAML; em vez de muitas ferramentas, você (geralmente) precisa apenas de um único binário goreleaser.”



## Kubernetes bom

Também funciona para dependências de imagens de contêiner! Ideal para aplicações Go. Se o seu repositório local tiver licenças, elas também serão processadas no SPDX. Se o seu projeto for compilado em Go, as dependências serão processadas.

[Bom](https://github.com/kubernetes-sigs/bom) é um utilitário que permite criar, visualizar e transformar Listas de Materiais de Software (SBOMs).

O bom foi criado como parte do projeto de criação de uma SBOM para o projeto Kubernetes. Ele permite que autores de software gerem uma SBOM para seus projetos de forma simples, porém poderosa.”



Ferramenta SBOM da Microsoft

Sim, funciona com Linux e Mac, não apenas com Windows. Vem com um Dockerfile para você manter sua própria imagem. Vem com um guia de início rápido para GitHub Actions e Azure DevOps Pipelines!



A ferramenta [SBOM](https://github.com/microsoft/sbom-tool) é uma ferramenta altamente escalável e pronta para empresas para criar SBOMs compatíveis com SPDX 2.2 para qualquer variedade de artefatos.



Gerador SPDX SBOM

Funciona para uma variedade de linguagens ([consulte a documentação](https://github.com/opensbom-generator/spdx-sbom-generator#overview) ). Pode ser executado extraindo o código-fonte e executando-o diretamente ou executando a imagem Docker (melhor para fins de integração contínua).



A ferramenta spdx-sbom-generator ajuda a comunidade que deseja gerar Listas de Materiais de Software (SBOMs) SPDX com os gerenciadores de pacotes atuais. Ela possui uma interface de linha de comando (CLI) que permite gerar informações de SBOM, incluindo componentes, licenças, direitos autorais e referências de segurança do seu software, usando a especificação SPDX v2.2 e alinhando-se aos elementos mínimos conhecidos da NTIA. Ela determina automaticamente quais gerenciadores de pacotes ou sistemas de compilação estão sendo realmente usados ​​pelo software.




Syft

Oferece SPDX ou CycloneDX à sua escolha. Funciona com uma ampla variedade de linguagens (consulte a documentação para obter a lista completa). Uma Ação do GitHub está disponível para agilizar o processo, caso essa seja a sua plataforma de CI/CD preferida.



Syft é “uma ferramenta CLI e biblioteca Go para gerar uma lista de materiais de software (SBOM) a partir de imagens de contêiner e sistemas de arquivos”.



Resumo do SBOM

Repetindo nossa observação do início desta seção, você só precisa escolher uma única ferramenta que funcione para seu projeto, embora você possa usar uma segunda ferramenta se quiser produzir SBOMs nos formatos CycloneDX e SPDX.



Depois de automatizar a geração de SBOM no seu processo de liberação, é hora de assinar seus artefatos e gerar uma atestação.



Sobre a Cosign

Cosign é uma ferramenta de assinatura popular para imagens do Docker e outros artefatos, da [Sigstore](https://docs.sigstore.dev/).



Um dos benefícios adicionais do cosign é a capacidade de usar chaves efêmeras de provedores de autenticação confiáveis ​​por meio do protocolo OpenID Connect. Ao simplificar o gerenciamento de chaves, podemos gastar menos tempo gerenciando as complexidades do armazenamento de segredos.



Opcional: Instale no seu GitHub Actions Runner

Ao usar a ferramenta CLI no seu pipeline de lançamento, você pode automatizar o processo de assinatura.

Ou, se estiver usando o GitHub, você pode usar a ação do [instalador do cosign](https://github.com/sigstore/cosign-installer) no GitHub para agilizar o processo. Há um exemplo mais completo na documentação do instalador do cosign.



Nas etapas subsequentes, o cosign se integra bem com as ações oficiais do Docker no GitHub, como a ação metadata e a ação build-push. É fácil adicionar o cosign em uma etapa subsequente para executar a assinatura. Além disso, é conveniente usar os metadados das ações do GitHub existentes, juntamente com as saídas das ações do Docker, para assinar a imagem. Supondo que você já tenha implementado a ação do GitHub do instalador cosign mencionada acima, adicione a seguinte etapa:



```

- name: Assine as imagens com o token OIDC do GitHub
env:
DIGEST: ${{ steps.build-and-push.outputs.digest }}
TAGS: ${{ steps.docker_meta.outputs.tags }}
run: cosign sign --yes "${TAGS}@${DIGEST}"
```



Artefatos de sinal com cosign
Após instalar o cosign, você poderá usá-lo para assinar diversos artefatos de procedência. Siga os links abaixo para obter a documentação mais recente de cada um:

- [ ] Recipientes
- [ ] Arquivos e objetos binários grande
- [ ] Commits do Git (https://docs.sigstore.dev/cosign/signing/git_support/)
- [ ] SBOMs
- [ ] Pacotes Tekton
- [ ] Módulos de montagem da Web
- [ ] Artefatos OCI
- [ ] Tags de registro
- [ ] Imagens e camadas de base
- [ ] Assinaturas (para contra-assinatura)



Depois de seguir as instruções correspondentes para assinar um artefato, você estará pronto para gerar uma atestação.



## Noções básicas de automação SLSA

Como abordamos no capítulo anterior sobre SLSA, podemos alcançar o Nível 3 utilizando um construtor confiável como o GitHub. O SLSA criou uma ação no GitHub que ajuda a facilitar o processo de atestação, e veremos como o Projeto Argo utiliza a ferramenta em seu ciclo de lançamento do Argo CD.



O SLSA-github-generator é capaz de lidar com diferentes tipos de artefatos para ajudar a otimizar nossas atestações. Por exemplo, com imagens do Docker, ele usa o cosign attest ( documentação do cosign attest ) para gerar a atestação.



O processo geral para usar o SLSA-github-generator na prática é o seguinte:



- [ ] Fonte de checkout
- [ ] Construir a partir da fonte
- [ ] Gerar hashes/checksums para artefatos
- [ ] Gerar procedência com slsa-github-generator

Um ótimo exemplo em ação é o fluxo de trabalho de lançamento do Argo CD . Essa automação repete o processo de geração diversas vezes para artefatos gerados durante o lançamento:

- [ ] Depois de construir a imagem do Docker
- [ ] Depois de construir os arquivos CLI
- [ ] Após gerar SBOM (com SPDX)


Seguiremos etapas semelhantes para executar nossas assinaturas e atestados e carregá-los como artefatos com nossa versão

## Adicionar SLSA às ações do GitHub
Para gerar procedência com SLSA, usaremos a ação slsa-github-generator. Essa ação suporta vários tipos de artefatos por meio de construtores e pode ser facilmente reutilizada diversas vezes em um fluxo de trabalho de lançamento.
Consulte a documentação do slsa-github-generator para obter mais informações.
Embora haja vários construtores disponíveis, muitos projetos se beneficiariam ao menos de começar com o Gerador Genérico, pois ele exige menos refatoração dos processos de construção existentes.

A próxima página contém um exemplo de uma etapa de ação do SLSA GitHub.

## Executando e automatizando a verificação de liberação
SBOM e a procedência como prática estão se expandindo rapidamente, mas ainda são novidades para muitos usuários e existem muitas maneiras diferentes pelas quais os mantenedores de projetos os realizam atualmente. Para ajudar seus adotantes, forneça orientações sobre como eles podem verificar e confiar em seu software.



O Argo CD fornece ampla documentação sobre como executar (e automatizar) a verificação de versão, e a documentação muda conforme os métodos de verificação.



Você deve:



Liste cada artefato esperado e suas localizações.

Liste cada tipo de artefato.

Liste as ferramentas usadas para assinar e verificar os artefatos e forneça instruções para verificação.
