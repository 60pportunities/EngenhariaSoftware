Desde o surgimento dos primeiros computadores, os **projetos de software** têm desempenhado um papel crucial na evolução da tecnologia e na forma como interagimos com o mundo digital.

Nos primeiros dias da computação, os projetos de software eram frequentemente limitados a programas simples e específicos, desenvolvidos por pioneiros da computação que trabalhavam com máquinas enormes e de capacidade limitada.

As abordagens de desenvolvimento eram **muitas vezes informais**, e havia um foco em programas escritos de **maneira ad hoc**, sem muita consideração para arquitetura, modularização ou usabilidade. A falta de padrões e metodologias levaram a uma grande **quantidade de erros e falhas afetando custos, credibilidade, confiabilidade e robustez dos mesmos**.

A necessidade de integrar novos recursos e melhorar a funcionalidade fez com que o software se tornasse cada vez mais complexo, o que complicava sua construção, teste e manutenção.

As abordagens de desenvolvimento eram **muitas vezes informais**, e havia um foco em programas escritos de **maneira ad hoc**, sem muita consideração para arquitetura, modularização ou usabilidade. A falta de padrões e metodologias levaram a uma grande **quantidade de erros e falhas afetando custos, credibilidade, confiabilidade e robustez dos mesmos**.

Em 1966, Böhm e Jacopini publicaram o teorema que é considerado a base teórica da programação estruturada, mostrando que qualquer programa pode ser escrito usando apenas três estruturas de controle:

- [ ] Sequência: Executando um subprograma e depois outro subprograma;
- [ ] Seleção: Executando um dos dois subprogramas de acordo com o valor de uma expressão booleana;iteração:
- [ ] Executar repetidamente um subprograma enquanto uma expressão booleana for verdadeira;

**A Crise do Software**, evidenciado a necessidade urgente de novos processos, metodologias e técnicas para o desenvolvimento de software, surge a Conferência de Garmisch, realizada em 1968 na Alemanha, que foi organizada pela ACM (Association for Computing Machinery). Como resultado desta conferência, houve a publicação de "**Software Engineering**", que descrevia os desafios da indústria de software e sugeria que a engenharia de software se tornasse uma disciplina acadêmica formal, com metodologias e práticas rigorosas.

Em 1969, a OTAN (Organização do Tratado do Atlântico Norte) organizou outra conferência, focada no desenvolvimento de software e suas deficiências. Nesse evento, discutiu-se a criação da **_Engenharia de Software_** como uma resposta à crescente crise. Neste encontro enfatizou-se a necessidade em desenvolver software de maneira científica, utilizando métodos formais de análise e design estruturado.

Winston Royce, propõe o que é agora popularmente designado no **Modelo em Cascata** como um conceito inicial, um modelo no qual ele **argumentava ser defeituoso** e defendia uma abordagem iterativa para o desenvolvimento de software, porém há citações da criação do Modelo em Cascata (Waterfall) sendo criado por ele Winston Royce.

No mesmo ano,  o conceito ganhou força com a publicação de artigos e livros de Edsger W. Dijkstra, um dos pioneiros da **programação estruturada**, que argumentava contra o uso indiscriminado de comandos goto e defendendo a organização do código em blocos estruturados.

Fred Brooks, em 1975, com sua publicação **The Mythical Man-month** cita conceitos, que são de suma importância ao processo de agilidade.

- [ ] **Feature Teams**, multidisciplinar com um Líder Técnico, de no máximo 10 pessoas;
- [ ] **Principal causa de fiasco de projetos - COMUNICAÇÃO**;

E **Harlan Mills**, enfatiza que a programação deveria ser um processo público, e que expor todo o trabalho pra todo mundo ajuda o controle de qualidade.
Cunha o conceito de **"Integridade conceitual"**, sendo o mais importante a se considerar em design de sistemas.

É melhor um sistema omitir certas features e melhorias, mas refletir apenas um conjunto de idéias de design

- [ ] Ditador Benevolente - PRODUCT OWNER;
- [ ] Planeje jogar um FORA (A primeira versão será sempre a pior);
- [ ] Prepare o gerenciamento do PROJETO para aceitar as MUDANÇAS;

A década de 1980 marcou um ponto de inflexão significativo na história dos projetos de software, com a popularização dos computadores pessoais, democratizando o acesso à tecnologia e criando uma nova onda de inovação no desenvolvimento de software.

Em 1990, surge então o termo SCRUM, ele foi retirado do Livro Wicked Problems, righteous solutions, trazendo pela primeira vez a ideia de utilizarmos no desenvolvimento de software o conjunto de práticas descritas pelos dois autores japoneses na reconhecida revista.

E foi nesse mesmo livro que seus autores, DeGrace e Stahl, batizaram essa nova forma de trabalhar de “Scrum“.


A **agilidade organizacional** é a capacidade de uma empresa se adaptar rapidamente a mudanças, entregar valor de forma iterativa e responder às necessidades do mercado e dos clientes.

Surgiu como resposta à rigidez de modelos tradicionais (como o _waterfall_), priorizando colaboração, flexibilidade e aprendizado contínuo. Seus pilares incluem:

- [ ] **Entrega iterativa e incremental**;
- [ ] **Colaboração multidisciplinar**;
- [ ] **Feedback constante de usuários e stakeholders**;
- [ ] **Melhoria contínua de processos**;

### **Princípios Fundamentais do Manifesto Ágil**

O _Manifesto Ágil_ (2001) estabelece 12 princípios, resumidos em quatro valores centrais:

- [ ] **Indivíduos e interações** sobre processos e ferramentas.
- [ ] **Software funcionando** sobre documentação extensiva.
- [ ] **Colaboração com o cliente** sobre negociação de contratos.
- [ ] **Responder a mudanças** sobre seguir um plano fixo.

### **Frameworks Ágeis Mais Utilizados**

#### **Scrum**

- [ ] **Foco:** Gerenciamento de projetos complexos via ciclos curtos (_sprints_).
- [ ] **Papéis:** _Product Owner_, _Scrum Master_, Time de Desenvolvimento.
- [ ] **Artefatos:** _Product Backlog_, _Sprint Backlog_, Incremento.
- [ ] **Eventos:** _Sprint Planning_, _Daily Scrum_, _Sprint Review_, _Retrospectiva_.
#### **Kanban**

- [ ] **Foco:** Visualização do fluxo de trabalho e limitação de tarefas em progresso.
- [ ] **Práticas:** Quadro Kanban (To Do, Doing, Done), métricas como _Lead Time_ e _Cycle Time_.

#### **SAFe (Scaled Agile Framework)**

- [ ] **Foco:** Escalar agilidade para grandes organizações.
- [ ] **Níveis:** Equipe, Programa, Portfolio.
- [ ] **Mecanismos:** _PI Planning_ (Planejamento de Incremento de Programa), _Agile Release Train_.
#### **LeSS (Large Scale Scrum)**

- [ ] **Foco:** Aplicação do Scrum em múltiplas equipes com mínima burocracia.

### **BizDev e a Estratégia Ágil**
O **BizDev (Business Development)** alinha-se à agilidade ao buscar oportunidades de crescimento de forma dinâmica e orientada a dados. Em contextos ágeis:

- [ ] **Integração com Product Management:** Definição de _roadmaps_ estratégicos que balanceiam inovação e demanda do mercado.
- [ ] **Parcerias Ágeis:** Modelos flexíveis de colaboração com parceiros, usando MVPs para validar hipóteses comerciais.
- [ ] **Exemplo:** Uma empresa de e-commerce que testa parcerias com influenciadores via campanhas curtas, medindo ROI em tempo real.
### **DevOps: A Engrenagem da Entrega Contínua**
O **DevOps** é um pilar técnico da agilidade, eliminando gargalos entre desenvolvimento e operações:

- [ ] **CI/CD (_Continuous Integration/Continuous Delivery_):** Automação de testes e implantações, reduzindo erros e acelerando _time-to-market_.
- [ ] **Infraestrutura como Código:** Ferramentas como Terraform ou Ansible permitem replicação ágil de ambientes.
- [ ] **Monitoramento Proativo:** Soluções como Prometheus e New Relic garantem estabilidade pós-implantação.
- [ ] **Sinergia com Scrum/Kanban:** Pipelines DevOps são integrados a sprints para entregas semanais ou diárias.

###  **InnerSource: Colaboração sem Silos**
O **InnerSource** aplica práticas de código aberto internamente, fortalecendo a cultura ágil:

- [ ] **Repositórios Compartilhados:** Plataformas como GitLab ou GitHub Enterprise permitem contribuições transversais.
- [ ] **Revisão por Pares:** Equipes de diferentes áreas revisam código, promovendo padrões técnicos unificados.
- [ ] **Exemplo:** Um banco onde equipes de segurança e desenvolvimento colaboram em uma biblioteca de autenticação interna.
- [ ] **Impacto na Agilidade:** Redução de duplicação de esforços e aceleração do desenvolvimento de features.


### **Experimentação Contínua: Validação no Mundo Real**
A **Experimentação Contínua** é a prática de testar hipóteses rapidamente, alinhada a ciclos ágeis:

- [ ]  **MVPs (_Minimum Viable Products_):** Versões simplificadas para validar demanda.
- [ ] **Testes A/B:** Comparação de variações de funcionalidades ou interfaces.
- [ ] _Feature Flags_: Liberação gradual de features para mitigar riscos.
- [ ] **Ferramentas:** Optimizely (testes A/B), LaunchDarkly (_feature flags_).
- [ ] **Conexão com Scrum:** Experimentos são priorizados no _Product Backlog_ e validados em sprints.
### **Integração dos Conceitos em um Ecossistema Ágil**
A combinação de **BizDev, DevOps, InnerSource e Experimentação Contínua** cria um ciclo virtuoso:

- [ ] **BizDev** identifica oportunidades estratégicas.
- [ ] **DevOps** viabiliza entregas rápidas e estáveis.
- [ ] **InnerSource** otimiza a colaboração técnica.
- [ ] **Experimentação Contínua** valida decisões com dados.
- [ ]  **Exemplo Prático:** Uma fintech lança um novo serviço de pagamento:
- [ ] BizDev propõe parcerias com marketplaces.
- [ ] Equipes usam InnerSource para reutilizar módulos de segurança existentes.
- [ ] DevOps automatiza a implantação em múltiplas regiões.
- [ ] estes A/B definem a interface ideal para conversão de usuários.
### **Desafios na Implementação**

- [ ] **Resistência Cultural:** Silos departamentais e aversão a mudanças.
- [ ] **Complexidade em Escala:** Frameworks como SAFe exigem alto alinhamento entre equipes.
- [ ] **Maturidade Técnica:** DevOps e InnerSource dependem de competências em automação e governança.
- [ ] **Métrica Errada:** Focar em "velocity" (velocidade) em vez de valor entregue ao cliente.
